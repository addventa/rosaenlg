name: Create Fix Branches and Issues (reusable)

on:
  workflow_call:
    inputs:
      branch:
        required: true
        type: string
        description: 'Branch name to create fix branches from'
      severity:
        required: true
        type: string
        description: 'Severity level(s) to filter (e.g., "high,critical" or "critical")'

permissions:
  contents: write  # Required to create branches
  security-events: read
  issues: write
  pull-requests: write

jobs:
  create-fix-artefacts:
    name: Create Fix Branches and Issues Artefacts
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
            
      - name: Log Found Alerts
        uses: ./.github/actions/log_codeql_alerts
        with:
          branch: ${{ inputs.branch }}
          severity: ${{ inputs.severity }}

      - name: Check and Create Fix Branches
        uses: actions/github-script@v7
        with:
          script: |
            // Read alerts data from file programmatically
            const fs = require('fs');
            const path = require('path');
            
            const alertsFilePath = path.join(process.cwd(), 'alerts_data.json');
            
            let alertsData;
            try {
              alertsData = fs.readFileSync(alertsFilePath, 'utf8').trim();
            } catch (error) {
              console.error('Failed to read alerts data file:', error);
              throw new Error(`Could not read alerts data file: ${error.message}`);
            }


            let alerts;
            try {
              alerts = JSON.parse(alertsData);
            } catch (error) {
              console.error('Failed to parse alerts data:', error);
              console.error('Raw data preview:', alertsData.substring(0, 200));
              throw new Error(`Invalid JSON in alerts data: ${error.message}`);
            }
            
            // Ensure alerts is an array
            if (!Array.isArray(alerts)) {
              console.log('Alerts is not an array, converting...');
              alerts = alerts ? [alerts] : [];
            }
            
            if (alerts.length === 0) {
              console.log('No alerts found. Skipping branch creation.');
              return;
            }
            
            console.log(`Processing ${alerts.length} alerts...`);

            for (const alert of alerts) {
              const branchName = `fix-codeql-alert-${alert.number}`;
              let branchExists = false;

              // Check if branch exists
              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branchName
                });
                console.log(`Branch ${branchName} already exists, skipping creation...`);
                branchExists = true;
              } catch (err) {
                if (err.status !== 404) throw err;
              }

              if (!branchExists) {
                // Create branch from specified branch
                console.log(`Creating branch ${branchName}...`);
                const sourceRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${{ inputs.branch }}`
                });

                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: sourceRef.data.object.sha
                });

                console.log(`Created branch ${branchName} from ${{ inputs.branch }}`);
              }
            }

      - name: Create Fix Issues
        uses: actions/github-script@v7
        with:
          script: |
            // Read alerts data from file programmatically
            const fs = require('fs');
            const path = require('path');
            
            const alertsFilePath = path.join(process.cwd(), 'alerts_data.json');
            
            let alertsData;
            try {
              alertsData = fs.readFileSync(alertsFilePath, 'utf8').trim();
            } catch (error) {
              console.error('Failed to read alerts data file:', error);
              throw new Error(`Could not read alerts data file: ${error.message}`);
            }
            
            // Debug: log what we received
            console.log('Raw alertsData length:', alertsData ? alertsData.length : 'null/undefined');
            
            let alerts;
            try {
              alerts = JSON.parse(alertsData);
            } catch (error) {
              console.error('Failed to parse alerts data:', error);
              console.error('Raw data preview:', alertsData.substring(0, 200));
              throw new Error(`Invalid JSON in alerts data: ${error.message}`);
            }
            
            // Ensure alerts is an array
            if (!Array.isArray(alerts)) {
              console.log('Alerts is not an array, converting...');
              alerts = alerts ? [alerts] : [];
            }
            
            if (alerts.length === 0) {
              console.log('No alerts found. Skipping issue creation.');
              return;
            }
            
            console.log(`Processing ${alerts.length} alerts...`);

            for (const alert of alerts) {
              const issueTitle = `[CodeQL] Fix vulnerability: ${alert.rule.description}`;
              const branchName = `fix-codeql-alert-${alert.number}`;
              
              // Check if an issue with the same title already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                creator: 'app/github-actions', // Optional: filter by creator if needed, or check labels
                labels: 'codeql,automated-fix' 
              });

              const issueExists = existingIssues.data.some(issue => issue.title === issueTitle);

              if (issueExists) {
                console.log(`Issue for alert #${alert.number} already exists, skipping creation...`);
                continue;
              }

              // Create issue
              const issueBody = [
                '## Vulnerability Details',
                '',
                `**Alert ID:** ${alert.number}`,
                `**Rule:** ${alert.rule.id}`,
                `**Severity:** ${alert.rule.severity}`,
                `**Description:** ${alert.rule.description}`,
                '',
                `**Location:** ${alert.most_recent_instance.location.path}:${alert.most_recent_instance.location.start_line}`,
                '',
                `**Source Branch:** \`${{ inputs.branch }}\``,
                `**Severity Filter:** \`${{ inputs.severity }}\``,
                `**Fix Branch:** \`${branchName}\``,
                '',
                'This issue was automatically created by the vulnerability detection workflow.',
                '',
                `[View Alert](${alert.html_url})`
              ].join('\n');

              // Build labels array - use alert's actual severity as label
              const severityLabel = alert.rule?.severity?.toLowerCase() || 'unknown';
              const labels = ['security', 'codeql', 'automated-fix'];
              if (severityLabel && !labels.includes(severityLabel)) {
                labels.push(severityLabel);
              }

              // Extract package name from location path and add as label
              const locationPath = alert.most_recent_instance.location.path;
              if (locationPath) {
                const pathParts = locationPath.split('/');
                if (pathParts.length >= 2 && pathParts[0] === 'packages') {
                  labels.push(`pkg:${pathParts[1]}`);
                }
              }

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels
              });

              console.log(`Created issue #${issue.data.number}`);
            }


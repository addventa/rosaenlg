name: Create Fix Branches and Issues (reusable)

on:
  workflow_call:
    inputs:
      branch:
        required: true
        type: string
        description: 'Branch name to create fix branches from'
      severity:
        required: true
        type: string
        description: 'Severity level(s) to filter (e.g., "high,critical" or "critical")'

permissions:
  contents: write  # Required to create branches
  security-events: write  # Required to update alerts (assign branches)
  issues: write
  pull-requests: write

jobs:
  create-fix-artefacts:
    name: Create Fix Branches and Issues Artefacts
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
            
      - name: Log Found Alerts
        uses: ./.github/actions/log_codeql_alerts
        with:
          branch: ${{ inputs.branch }}
          severity: ${{ inputs.severity }}
          upload: true

      - name: Check and Create Fix Branches
        uses: actions/github-script@v7
        with:
          script: |
            // Read alerts data from file programmatically
            const fs = require('fs');
            const path = require('path');
            
            const alertsFilePath = path.join(process.cwd(), 'alerts_data.json');
            
            let alertsData;
            try {
              alertsData = fs.readFileSync(alertsFilePath, 'utf8').trim();
            } catch (error) {
              console.error('Failed to read alerts data file:', error);
              throw new Error(`Could not read alerts data file: ${error.message}`);
            }

            let alerts;
            try {
              alerts = JSON.parse(alertsData);
            } catch (error) {
              console.error('Failed to parse alerts data:', error);
              console.error('Raw data preview:', alertsData.substring(0, 200));
              throw new Error(`Invalid JSON in alerts data: ${error.message}`);
            }
            
            // Ensure alerts is an array
            if (!Array.isArray(alerts)) {
              console.log('Alerts is not an array, converting...');
              alerts = alerts ? [alerts] : [];
            }
            
            if (alerts.length === 0) {
              console.log('No alerts found. Skipping branch creation.');
              return;
            }
            
            console.log(`Processing ${alerts.length} alerts...`);

            for (const alert of alerts) {
              const branchName = `fix-codeql-alert-${alert.number}`;
              let branchExists = false;

              try {
                await github.rest.repos.getBranch({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  branch: branchName
                });
                console.log(`Branch ${branchName} already exists, skipping creation...`);
                branchExists = true;
              } catch (err) {
                if (err.status !== 404) throw err;
              }
              
              if (!branchExists) {
                // Create branch from specified branch
                console.log(`Creating branch ${branchName}...`);
                const sourceRef = await github.rest.git.getRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `heads/${{ inputs.branch }}`
                });

                await github.rest.git.createRef({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  ref: `refs/heads/${branchName}`,
                  sha: sourceRef.data.object.sha
                });

                console.log(`Created branch ${branchName} from ${{ inputs.branch }}`);
              }
            }

      - name: Create Fix Issues
        uses: actions/github-script@v7
        with:
          script: |
            // Read alerts data from file programmatically
            const fs = require('fs');
            const path = require('path');
            
            const alertsFilePath = path.join(process.cwd(), 'alerts_data.json');
            
            let alertsData;
            try {
              alertsData = fs.readFileSync(alertsFilePath, 'utf8').trim();
            } catch (error) {
              console.error('Failed to read alerts data file:', error);
              throw new Error(`Could not read alerts data file: ${error.message}`);
            }
            
            // Debug: log what we received
            console.log('Raw alertsData length:', alertsData ? alertsData.length : 'null/undefined');
            
            let alerts;
            try {
              alerts = JSON.parse(alertsData);
            } catch (error) {
              console.error('Failed to parse alerts data:', error);
              console.error('Raw data preview:', alertsData.substring(0, 200));
              throw new Error(`Invalid JSON in alerts data: ${error.message}`);
            }
            
            // Ensure alerts is an array
            if (!Array.isArray(alerts)) {
              console.log('Alerts is not an array, converting...');
              alerts = alerts ? [alerts] : [];
            }
            
            if (alerts.length === 0) {
              console.log('No alerts found. Skipping issue creation.');
              return;
            }
            
            console.log(`Processing ${alerts.length} alerts...`);

            for (const alert of alerts) {
              const issueTitle = `[CodeQL] Fix vulnerability: ${alert.rule.description}`;
              const branchName = `fix-codeql-alert-${alert.number}`;
              
              // Check if an issue with the same title already exists
              const existingIssues = await github.rest.issues.listForRepo({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                creator: 'app/github-actions', // Optional: filter by creator if needed, or check labels
                labels: 'codeql,automated-fix' 
              });

              const issueExists = existingIssues.data.some(issue => issue.title === issueTitle);

              if (issueExists) {
                console.log(`Issue for alert #${alert.number} already exists, skipping creation...`);
                continue;
              }

              // Create issue
              const issueBody = [
                '## Vulnerability Details',
                '',
                `**Alert ID:** ${alert.number}`,
                `**Rule:** ${alert.rule.id}`,
                `**Severity:** ${alert.rule.severity}`,
                `**Description:** ${alert.rule.description}`,
                '',
                `**Location:** ${alert.most_recent_instance.location.path}:${alert.most_recent_instance.location.start_line}`,
                '',
                `**Source Branch:** \`${{ inputs.branch }}\``,
                `**Severity Filter:** \`${{ inputs.severity }}\``,
                `**Fix Branch:** \`${branchName}\``,
                '',
                'This issue was automatically created by the vulnerability detection workflow.',
                '',
                `[View Alert](${alert.html_url})`
              ].join('\n');

              // Build labels array - use alert's actual severity as label
              const severityLabel = alert.rule?.severity?.toLowerCase() || 'unknown';
              const labels = ['security', 'codeql', 'automated-fix'];
              if (severityLabel && !labels.includes(severityLabel)) {
                labels.push(severityLabel);
              }

              // Extract package name from location path and add as label
              const locationPath = alert.most_recent_instance.location.path;
              if (locationPath) {
                const pathParts = locationPath.split('/');
                if (pathParts.length >= 2 && pathParts[0] === 'packages') {
                  labels.push(`pkg:${pathParts[1]}`);
              }

              // Check if a branch is already assigned/attached to this alert, and assign/attach this branch otherwise
              try {
                // Get the alert details to check which ref it exists on
                const alertDetails = await github.rest.codeScanning.getAlert({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  alert_number: alert.number
                });

                const alertRef = alertDetails.data.ref;
                const alertRefName = alertRef ? alertRef.replace('refs/heads/', '') : null;
                
                // Check if the alert is already on our fix branch
                if (alertRefName === branchName) {
                  console.log(`Alert #${alert.number} is already associated with branch ${branchName}`);
                } else {
                  // Check if there's another fix branch for this alert
                  let branchAlreadyAssigned = false;
                  
                  if (alertRefName && alertRefName.startsWith('fix-codeql-alert-')) {
                    // Extract alert number from branch name
                    const match = alertRefName.match(/^fix-codeql-alert-(\d+)$/);
                    if (match && match[1] === alert.number.toString()) {
                      branchAlreadyAssigned = true;
                      console.log(`Alert #${alert.number} is already associated with branch ${alertRefName}, skipping assignment of ${branchName}`);
                    }
                  }

                  if (!branchAlreadyAssigned) {
                    // Update the alert to assign/attach the fix branch to it by setting its ref
                    try {
                      await github.rest.codeScanning.updateAlert({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                        alert_number: alert.number,
                        ref: `refs/heads/${branchName}`
                      });
                      console.log(`Successfully assigned branch ${branchName} to alert #${alert.number}`);
                    } catch (error) {
                      // If updating ref is not supported by the API, log the error but continue
                      console.error(`Failed to assign branch ${branchName} to alert #${alert.number}:`, error.message);
                      console.log(`Note: Alert #${alert.number} is tracked for fix branch ${branchName}, but ref update may not be supported by the API`);
                    }
                  }
                }
              } catch (error) {
                console.error(`Error checking branch assignment for alert #${alert.number}:`, error.message);
                // Continue processing other alerts even if one fails
              }
            }

              const issue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: issueTitle,
                body: issueBody,
                labels: labels
              });

              console.log(`Created issue #${issue.data.number}`);
            }

